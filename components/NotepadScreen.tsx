    const handleContextMenuAction = (action: string, payload?: any) => { if (!contextMenu) return; const { id, type, connectionType, pointIndex, clickPos } = contextMenu; if (type === 'canvas') { if (action === 'create_note') addNoteAt(contextMenu.x, contextMenu.y, true); if (action === 'snip_text') handleSnipText(); if (action === 'upload_image') { uploadTriggerPos.current = { x: contextMenu.x, y: contextMenu.y }; handleImageUpload(); } if (action === 'create_image_placeholder') addNoteAt(contextMenu.x, contextMenu.y, true, 'image', { isPlaceholder: true }); if (action === 'add_audio') addNoteAt(contextMenu.x, contextMenu.y, true, 'audio'); if (action === 'add_table') addNoteAt(contextMenu.x, contextMenu.y, true, 'table'); if (action === 'add_drawing') addNoteAt(contextMenu.x, contextMenu.y, true, 'drawing'); if (action === 'paste') handlePaste(); if (action === 'reset_view') centerView(); } else if (type === 'annotation' && id) { if (action === 'delete_annotation') { const pageAnns = annotations[pageNum] || []; const newAnns = pageAnns.filter(a => a.id !== id); setAnnotations({ ...annotations, [pageNum]: newAnns }); commitToHistory({ ...annotations, [pageNum]: newAnns }, stickyNotes, noteConnections); setSelectedAnnotationId(null); } else if (action === 'change_color') { const pageAnns = annotations[pageNum] || []; const newAnns = pageAnns.map(a => a.id === id ? { ...a, color: payload as string } : a); setAnnotations({ ...annotations, [pageNum]: newAnns }); commitToHistory({ ...annotations, [pageNum]: newAnns }, stickyNotes, noteConnections); } else if (action === 'toggle_arrow') { const pageAnns = annotations[pageNum] || []; const newAnns = pageAnns.map(a => { if (a.id === id && a.type === 'arrow') { return { ...a, arrowType: (a.arrowType === 'double' ? 'single' : 'double') as 'single' | 'double' }; } return a; }); setAnnotations({ ...annotations, [pageNum]: newAnns }); commitToHistory({ ...annotations, [pageNum]: newAnns }, stickyNotes, noteConnections); } } else if (type === 'note' && id) { if (action === 'color') commitToHistory(annotations, { ...stickyNotes, [pageNum]: (stickyNotes[pageNum]||[]).map(n => n.id === id ? { ...n, color: payload as string } : n) }, noteConnections); else if (action === 'add_child') addChildNote(id); else if (action === 'add_anchor') startAnchorLinking(id); else if (action === 'delete') deleteNote(id); } else if (type === 'connection' && id) { if (connectionType === 'anchorConnection') { const note = stickyNotes[pageNum]?.find(n => n.id === id); if (note) { if (action === 'connection_color') commitToHistory(annotations, { ...stickyNotes, [pageNum]: (stickyNotes[pageNum]||[]).map(n => n.id === id ? { ...n, connectionColor: payload as string } : n) }, noteConnections); else if (action === 'connection_style') commitToHistory(annotations, { ...stickyNotes, [pageNum]: (stickyNotes[pageNum]||[]).map(n => n.id === id ? { ...n, connectionStyle: payload as any } : n) }, noteConnections); else if (action === 'add_point') { const currentPoints = note.controlPoints || []; const newPoint = clickPos || { x: note.x, y: note.y }; if (contentDimensions && note.anchor) { const contentW = contentDimensions.width; const contentH = contentDimensions.height; const topLeftX = CANVAS_CENTER - contentW / 2; const topLeftY = CANVAS_CENTER - contentH / 2; const anchorX = topLeftX + (note.anchor.x / 100) * contentW; const anchorY = topLeftY + (note.anchor.y / 100) * contentH; const start = { x: anchorX, y: anchorY }; const end = getNoteCenter(note); const insertIdx = getInsertionIndex(currentPoints, newPoint, start, end); const newPointsList = [...currentPoints]; newPointsList.splice(insertIdx, 0, newPoint); commitToHistory(annotations, { ...stickyNotes, [pageNum]: (stickyNotes[pageNum]||[]).map(n => n.id === id ? { ...n, controlPoints: newPointsList } : n) }, noteConnections); } else { commitToHistory(annotations, { ...stickyNotes, [pageNum]: (stickyNotes[pageNum]||[]).map(n => n.id === id ? { ...n, controlPoints: [...currentPoints, newPoint] } : n) }, noteConnections); } } else if (action === 'delete_link') deleteAnchorConnection(id); } } else if (connectionType === 'noteConnection') { const pageConns = noteConnections[pageNum] || []; const conn = pageConns.find(c => c.id === id); if (conn) { if (action === 'connection_color') commitToHistory(annotations, stickyNotes, { ...noteConnections, [pageNum]: pageConns.map(c => c.id === id ? { ...c, color: payload as string } : c) }); else if (action === 'connection_style') commitToHistory(annotations, stickyNotes, { ...noteConnections, [pageNum]: pageConns.map(c => c.id === id ? { ...c, style: payload as any } : c) }); else if (action === 'add_point') { const newPoint = clickPos || { x: 0, y: 0 }; const sourceNote = stickyNotes[pageNum]?.find(n => n.id === conn.sourceId); const targetNote = stickyNotes[pageNum]?.find(n => n.id === conn.targetId); if (sourceNote && targetNote) { const start = getNoteCenter(sourceNote); const end = getNoteCenter(targetNote); const currentPoints = conn.controlPoints || []; const insertIdx = getInsertionIndex(currentPoints, newPoint, start, end); const newPointsList = [...currentPoints]; newPointsList.splice(insertIdx, 0, newPoint); commitToHistory(annotations, stickyNotes, { ...noteConnections, [pageNum]: pageConns.map(c => c.id === id ? { ...c, controlPoints: newPointsList } : c) }); } else { commitToHistory(annotations, stickyNotes, { ...noteConnections, [pageNum]: pageConns.map(c => c.id === id ? { ...c, controlPoints: [...(c.controlPoints||[]), newPoint] } : c) }); } } else if (action === 'delete_link') deleteConnection(id); } } } else if (type === 'controlPoint' && id && pointIndex !== undefined) { if (action === 'delete_point') { const note = stickyNotes[pageNum]?.find(n => n.id === id); if (note) { const newPoints = [...(note.controlPoints || [])]; newPoints.splice(pointIndex, 1); const newNotes = { ...stickyNotes, [pageNum]: (stickyNotes[pageNum]||[]).map(n => n.id === id ? { ...n, controlPoints: newPoints } : n) }; setStickyNotes(newNotes); commitToHistory(annotations, newNotes, noteConnections); } else { const pageConns = noteConnections[pageNum] || []; const conn = pageConns.find(c => c.id === id); if (conn && conn.controlPoints) { const newPoints = [...conn.controlPoints]; newPoints.splice(pointIndex, 1); const newConns = { ...noteConnections, [pageNum]: pageConns.map(c => c.id === id ? { ...c, controlPoints: newPoints } : c) }; setNoteConnections(newConns); commitToHistory(annotations, stickyNotes, newConns); } } } } setContextMenu(null); };