
import { SingularityNode, EdgeOptions, ExportConfig } from '../types';
import * as htmlToImage from 'html-to-image';

/**
 * Calculates the bounding box of the entire map content.
 * Adds padding to ensure nothing is cut off.
 */
export const getMapBoundingBox = (nodes: SingularityNode[], padding: number = 100) => {
    if (nodes.length === 0) return { x: 0, y: 0, width: 800, height: 600 };

    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;

    nodes.forEach(node => {
        // Approximate visual size if not tracked explicitly (e.g. 200x100 for standard nodes)
        const width = node.type === 'ROOT' ? 300 : 250;
        const height = 200; 
        
        // Check node center + half dimensions
        minX = Math.min(minX, node.position.x - width / 2);
        minY = Math.min(minY, node.position.y - height / 2);
        maxX = Math.max(maxX, node.position.x + width / 2);
        maxY = Math.max(maxY, node.position.y + height / 2);
    });

    return {
        x: minX - padding,
        y: minY - padding,
        width: (maxX - minX) + (padding * 2),
        height: (maxY - minY) + (padding * 2)
    };
};

/**
 * Generates an image Blob or Data URL from the map.
 * Used for both Preview and Final Download.
 */
export const generateMapImage = async (
    nodes: SingularityNode[], 
    format: 'PNG' | 'JPEG' | 'SVG', 
    elementId: string,
    exportConfig: ExportConfig,
    pixelRatio: number = 1
): Promise<string | null> => {
    const element = document.getElementById(elementId);
    if (!element) {
        console.error("Export element not found");
        return null;
    }

    const bounds = getMapBoundingBox(nodes, exportConfig.padding);
    const backgroundStyle = exportConfig.backgroundStyle || '#f0f4f8';

    // Configuration for html-to-image
    const config = {
        width: bounds.width,
        height: bounds.height,
        style: {
            transform: `translate(${-bounds.x}px, ${-bounds.y}px) scale(1)`,
            transformOrigin: 'top left',
            width: `${bounds.width}px`,
            height: `${bounds.height}px`,
            background: backgroundStyle,
        },
        pixelRatio: pixelRatio,
        backgroundColor: backgroundStyle.startsWith('#') || backgroundStyle.startsWith('rgb') ? backgroundStyle : undefined,
        fontEmbedCSS: '', // Disable font embedding to prevent CORS errors
        skipAutoScale: true, // Prevent automatic scaling which can distort large maps
        filter: (node: HTMLElement) => {
            // Exclude UI controls
            return !node.className?.toString().includes('no-export');
        },
        onClone: (clonedNode: HTMLElement) => {
            // --- OVERLAY INJECTION ---
            const overlay = document.createElement('div');
            overlay.style.position = 'absolute';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.pointerEvents = 'none';
            overlay.style.zIndex = '9999';
            overlay.style.display = 'flex';
            overlay.style.flexDirection = 'column';
            overlay.style.justifyContent = 'space-between';
            overlay.style.padding = '40px';
            overlay.style.boxSizing = 'border-box';

            // 1. TOP LEFT: Logo & Title
            const topSection = document.createElement('div');
            topSection.style.display = 'flex';
            topSection.style.flexDirection = 'column';
            topSection.style.gap = '15px';
            topSection.style.alignItems = 'flex-start';

            // Logo Badge
            const logo = document.createElement('div');
            logo.innerHTML = `
                <div style="display:flex; align-items:center; gap:12px; background: rgba(255,255,255,0.95); padding: 12px 24px; border-radius: 50px; box-shadow: 0 10px 25px -5px rgba(0,0,0,0.1), 0 8px 10px -6px rgba(0,0,0,0.1); border: 1px solid rgba(255,255,255,0.5); backdrop-filter: blur(12px);">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#4F46E5" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2z"></path>
                        <path d="M12 8a4 4 0 1 0 0 8 4 4 0 1 0 0-8z"></path>
                    </svg>
                    <span style="font-family: 'Fredoka', 'Nunito', sans-serif; font-weight: 700; font-size: 18px; color: #1e293b; letter-spacing: 0.5px; white-space: nowrap;">Generated by Singularity Mind Map</span>
                </div>
            `;
            topSection.appendChild(logo);

            // Optional Title
            if (exportConfig.showTitle && exportConfig.projectName) {
                const titleCard = document.createElement('div');
                titleCard.style.cssText = `
                    background: rgba(255, 255, 255, 0.7);
                    backdrop-filter: blur(4px);
                    padding: 10px 20px;
                    border-radius: 12px;
                    border-left: 5px solid #4F46E5;
                    margin-left: 5px;
                `;
                const title = document.createElement('h1');
                title.innerText = exportConfig.projectName;
                title.style.cssText = `
                    font-family: 'Nunito', sans-serif; 
                    font-weight: 900; 
                    font-size: 42px; 
                    color: #0f172a; 
                    margin: 0; 
                    line-height: 1.1;
                    text-shadow: 0 2px 0 rgba(255,255,255,0.8);
                `;
                titleCard.appendChild(title);
                topSection.appendChild(titleCard);
            }
            overlay.appendChild(topSection);

            // 2. BOTTOM LEFT: Metadata
            // Robust Date Logic (Fix)
            let dateStr = "Date Error";
            let timeStr = "--:--:--";
            
            try {
                const now = new Date();
                if (!isNaN(now.getTime())) {
                    const months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
                    const pad = (num: number) => num.toString().padStart(2, '0');

                    const day = now.getDate();
                    const month = months[now.getMonth()];
                    const year = now.getFullYear();
                    
                    // Format: 29, November, 2025
                    dateStr = `${day}, ${month}, ${year}`;
                    
                    // Format: HH:MM:SS
                    timeStr = `${pad(now.getHours())}:${pad(now.getMinutes())}:${pad(now.getSeconds())}`;
                }
            } catch (e) {
                console.error("Date formatting failed during export", e);
            }

            const bottomSection = document.createElement('div');
            bottomSection.innerHTML = `
                <div style="font-family: 'Nunito', sans-serif; font-size: 14px; color: #475569; background: rgba(255,255,255,0.9); padding: 12px 20px; border-radius: 12px; backdrop-filter: blur(8px); display: inline-flex; flex-direction: column; gap: 4px; border: 1px solid rgba(203, 213, 225, 0.5); box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#64748b" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>
                        <span style="font-weight: 800; color: #0f172a;">${dateStr}</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#64748b" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>
                        <span style="font-family: monospace; letter-spacing: 0.5px; font-weight: 600;">${timeStr}</span>
                    </div>
                </div>
            `;
            overlay.appendChild(bottomSection);

            clonedNode.appendChild(overlay);
        }
    };

    try {
        if (format === 'SVG') {
            return await htmlToImage.toSvg(element, config);
        } else if (format === 'JPEG') {
            return await htmlToImage.toJpeg(element, config);
        } else {
            return await htmlToImage.toPng(element, config);
        }
    } catch (err) {
        console.error('Image Generation Failed:', err);
        return null;
    }
};

/**
 * Public export function triggered by UI
 */
export const exportSmartImage = async (
    nodes: SingularityNode[], 
    projectName: string, 
    format: 'PNG' | 'JPEG' | 'SVG', 
    elementId: string,
    exportConfig: ExportConfig
) => {
    // For final export, we use a higher pixel ratio for better quality
    const pixelRatio = format === 'SVG' ? 1 : 2; 
    
    // Ensure project name is passed if not in config
    const finalConfig = { ...exportConfig, projectName };

    const dataUrl = await generateMapImage(nodes, format, elementId, finalConfig, pixelRatio);

    if (dataUrl) {
        const link = document.createElement('a');
        link.download = `${projectName.replace(/\s+/g, '_')}.${format.toLowerCase()}`;
        link.href = dataUrl;
        link.click();
    } else {
        alert("Export failed. Please check the console for details.");
    }
};

/**
 * Generates a standalone Interactive HTML file.
 */
export const generateInteractiveHTML = (
    nodes: SingularityNode[], 
    edgeData: Record<string, EdgeOptions>, 
    projectName: string,
    theme: any
) => {
    const safeData = JSON.stringify({ nodes, edgeData, theme }).replace(/<\/script>/g, '<\\/script>');

    const htmlContent = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${projectName} - Interactive View</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800&family=Fredoka:wght@400;600&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: ${theme.bg}; font-family: 'Nunito', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; cursor: grab; touch-action: none; }
        #canvas-container.grabbing { cursor: grabbing; }
        #canvas-content { transform-origin: 0 0; position: absolute; top: 0; left: 0; will-change: transform; }
        .node { position: absolute; transform: translate(-50%, -50%); transition: all 0.3s ease; box-shadow: 5px 5px 15px rgba(0,0,0,0.1); display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; }
        .node:hover { z-index: 50; transform: translate(-50%, -50%) scale(1.05); }
        .edge-path { fill: none; stroke-linecap: round; stroke-linejoin: round; transition: opacity 0.3s; }
        .toggle-btn { position: absolute; right: -12px; top: 50%; transform: translateY(-50%); width: 20px; height: 20px; background: white; border-radius: 50%; border: 1px solid #ccc; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 10px; z-index: 60; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .toggle-btn:hover { background: #eee; }
        .shape-circle { border-radius: 50%; aspect-ratio: 1/1; }
        .shape-rounded { border-radius: 2rem; }
        .shape-rectangle { border-radius: 0.5rem; }
        .shape-diamond { transform: translate(-50%, -50%) rotate(45deg); }
        .shape-diamond > div { transform: rotate(-45deg); }
    </style>
</head>
<body>
    <div id="canvas-container">
        <div id="canvas-content">
            <svg id="edges-layer" style="position: absolute; top: -50000px; left: -50000px; width: 100000px; height: 100000px; overflow: visible; pointer-events: none;"></svg>
            <div id="nodes-layer"></div>
        </div>
    </div>
    
    <div class="fixed bottom-4 right-4 bg-white/90 backdrop-blur px-4 py-2 rounded-full shadow-lg border border-gray-200 text-xs font-bold text-gray-600 select-none pointer-events-none">
        Read-Only Viewer • Singularity
    </div>

    <script>
        const DATA = ${safeData};
        const nodes = DATA.nodes;
        const edgeData = DATA.edgeData;
        
        let collapsed = new Set();
        let viewport = { x: window.innerWidth / 2, y: window.innerHeight / 2, zoom: 1 };
        let isDragging = false;
        let lastPos = { x: 0, y: 0 };

        const container = document.getElementById('canvas-container');
        const content = document.getElementById('canvas-content');
        const nodesLayer = document.getElementById('nodes-layer');
        const edgesLayer = document.getElementById('edges-layer');

        function render() {
            nodesLayer.innerHTML = '';
            edgesLayer.innerHTML = '';
            
            const visibleIds = new Set();
            const roots = nodes.filter(n => !n.parentId);
            const queue = [...roots.map(n => n.id)];
            
            while(queue.length > 0) {
                const id = queue.shift();
                visibleIds.add(id);
                if (!collapsed.has(id)) {
                    const node = nodes.find(n => n.id === id);
                    if(node && node.childrenIds) {
                        node.childrenIds.forEach(cid => queue.push(cid));
                    }
                }
            }

            const OFFSET = 50000; 

            nodes.forEach(node => {
                if (!visibleIds.has(node.id)) return;
                node.childrenIds.forEach(childId => {
                    if (!visibleIds.has(childId)) return;
                    const child = nodes.find(n => n.id === childId);
                    if (!child) return;

                    const edgeKey = node.id + '-' + child.id;
                    const opts = edgeData[edgeKey] || { color: '#cbd5e1', width: 2 };
                    
                    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    const start = { x: node.position.x + OFFSET, y: node.position.y + OFFSET };
                    const end = { x: child.position.x + OFFSET, y: child.position.y + OFFSET };
                    const dx = end.x - start.x;
                    const cp1 = { x: start.x + Math.min(Math.abs(dx)*0.8, 150), y: start.y };
                    const cp2 = { x: end.x - Math.min(Math.abs(dx)*0.8, 150), y: end.y };
                    const d = \`M \${start.x} \${start.y} C \${cp1.x} \${cp1.y}, \${cp2.x} \${cp2.y}, \${end.x} \${end.y}\`;
                    
                    path.setAttribute("d", d);
                    path.setAttribute("stroke", opts.color || '#cbd5e1');
                    path.setAttribute("stroke-width", opts.width || 2);
                    path.setAttribute("fill", "none");
                    path.classList.add("edge-path");
                    edgesLayer.appendChild(path);
                });
            });

            nodes.forEach(node => {
                if (!visibleIds.has(node.id)) return;
                const el = document.createElement('div');
                el.className = \`node shape-\${node.shape || 'rounded'}\`;
                const isRoot = node.type === 'ROOT';
                el.style.left = node.position.x + 'px';
                el.style.top = node.position.y + 'px';
                el.style.backgroundColor = node.color || '#ffffff';
                if (isRoot) { el.style.padding = '20px 40px'; el.style.fontSize = '24px'; el.style.fontWeight = '800'; el.style.color = 'white'; }
                else { el.style.padding = '12px 24px'; el.style.fontSize = '14px'; el.style.fontWeight = 'bold'; }
                const label = document.createElement('div');
                label.innerText = node.label;
                el.appendChild(label);
                if (node.childrenIds.length > 0) {
                    const btn = document.createElement('div');
                    btn.className = 'toggle-btn';
                    btn.innerText = collapsed.has(node.id) ? '+' : '-';
                    btn.onclick = (e) => { e.stopPropagation(); if (collapsed.has(node.id)) collapsed.delete(node.id); else collapsed.add(node.id); render(); };
                    el.appendChild(btn);
                }
                nodesLayer.appendChild(el);
            });
        }

        function updateTransform() { content.style.transform = \`translate(\${viewport.x}px, \${viewport.y}px) scale(\${viewport.zoom})\`; }
        container.addEventListener('mousedown', (e) => { isDragging = true; lastPos = { x: e.clientX, y: e.clientY }; container.classList.add('grabbing'); });
        window.addEventListener('mousemove', (e) => { if (!isDragging) return; const dx = e.clientX - lastPos.x; const dy = e.clientY - lastPos.y; viewport.x += dx; viewport.y += dy; lastPos = { x: e.clientX, y: e.clientY }; updateTransform(); });
        window.addEventListener('mouseup', () => { isDragging = false; container.classList.remove('grabbing'); });
        container.addEventListener('wheel', (e) => { e.preventDefault(); const s = Math.pow(1.001, -e.deltaY); viewport.zoom = Math.max(0.1, Math.min(5, viewport.zoom * s)); updateTransform(); }, { passive: false });
        render(); updateTransform();
    </script>
</body>
</html>`;

    const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8;' });
    const link = document.createElement("a");
    const url = URL.createObjectURL(blob);
    link.setAttribute("href", url);
    link.setAttribute("download", `${projectName.replace(/\s+/g, '_')}_interactive.html`);
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
};

export const exportToCSV = (nodes: SingularityNode[], projectName: string) => {
    const BOM = "\uFEFF"; 
    let csvContent = BOM + "Level 1,Level 2,Level 3,Level 4,Level 5,Type,Status,Notes\n";
    const traverse = (nodeId: string, depth: number, prefixColumns: string[]) => {
        const node = nodes.find(n => n.id === nodeId);
        if (!node) return;
        const safeLabel = `"${node.label.replace(/"/g, '""')}"`;
        const row = [...prefixColumns];
        row.push(safeLabel);
        for(let i = row.length; i < 5; i++) row.push("");
        row.push(node.type);
        row.push(node.checked !== undefined ? (node.checked ? "Done" : "Pending") : "");
        let notes = "";
        if (node.data?.description) notes += `[Desc: ${node.data.description}] `;
        if (node.data?.items) notes += `[Items: ${node.data.items.join(', ')}]`;
        row.push(`"${notes.replace(/"/g, '""')}"`);
        csvContent += row.join(",") + "\n";
        node.childrenIds.forEach(childId => { traverse(childId, depth + 1, new Array(depth + 1).fill("")); });
    };
    const roots = nodes.filter(n => !n.parentId);
    roots.forEach(root => traverse(root.id, 0, []));
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement("a");
    const url = URL.createObjectURL(blob);
    link.setAttribute("href", url);
    link.setAttribute("download", `${projectName.replace(/\s+/g, '_')}.csv`);
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
};

export const exportToOPML = (nodes: SingularityNode[], projectName: string) => {
    const escapeXml = (unsafe: string) => unsafe.replace(/[<>&'"]/g, (c) => { switch (c) { case '<': return '&lt;'; case '>': return '&gt;'; case '&': return '&amp;'; case '\'': return '&apos;'; case '"': return '&quot;'; default: return c; }});
    const traverse = (nodeId: string): string => {
        const node = nodes.find(n => n.id === nodeId);
        if (!node) return '';
        const text = escapeXml(node.label);
        const note = node.data?.description ? ` _note="${escapeXml(node.data.description)}"` : '';
        let childrenXml = '';
        if (node.childrenIds.length > 0) childrenXml = node.childrenIds.map(cid => traverse(cid)).join('');
        return `<outline text="${text}"${note}>\n${childrenXml}</outline>\n`;
    };
    const roots = nodes.filter(n => !n.parentId);
    const opmlContent = `<?xml version="1.0" encoding="UTF-8"?>\n<opml version="2.0">\n<head>\n<title>${escapeXml(projectName)}</title>\n<dateCreated>${new Date().toUTCString()}</dateCreated>\n</head>\n<body>\n${roots.map(r => traverse(r.id)).join('')}</body>\n</opml>`;
    const blob = new Blob([opmlContent], { type: 'text/xml;charset=utf-8;' });
    const link = document.createElement("a");
    const url = URL.createObjectURL(blob);
    link.setAttribute("href", url);
    link.setAttribute("download", `${projectName.replace(/\s+/g, '_')}.opml`);
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
};

export const exportToDoc = (nodes: SingularityNode[], projectName: string) => {
    const rootNodes = nodes.filter(n => !n.parentId);
    const generateList = (nodeId: string): string => {
        const node = nodes.find(n => n.id === nodeId);
        if (!node) return '';
        let html = `<li style="margin-bottom: 10px;"><span style="font-size: ${!node.parentId ? '16pt' : '12pt'}; font-weight: ${!node.parentId ? 'bold' : 'normal'}; font-family: Arial, sans-serif;">${node.label}</span>`;
        if (node.data?.description) html += `<br/><span style="color: #555; font-style: italic; font-size: 10pt;">${node.data.description}</span>`;
        if (node.data?.items && node.data.items.length > 0) html += `<ul style="list-style-type: square; margin-top: 5px; color: #444;">${node.data.items.map(i => `<li>${i}</li>`).join('')}</ul>`;
        if (node.childrenIds.length > 0) html += `<ul>${node.childrenIds.map(cid => generateList(cid)).join('')}</ul>`;
        html += `</li>`;
        return html;
    };
    const htmlContent = `<html xmlns:o='urn:schemas-microsoft-com:office:office' xmlns:w='urn:schemas-microsoft-com:office:word' xmlns='http://www.w3.org/TR/REC-html40'><head><meta charset='utf-8'><title>${projectName}</title><style>body { font-family: 'Calibri', 'Arial', sans-serif; line-height: 1.6; } ul { list-style-type: disc; } h1 { color: #4F46E5; font-size: 24pt; border-bottom: 2px solid #eee; padding-bottom: 10px; } .footer { font-size: 9pt; color: #888; margin-top: 50px; text-align: center; border-top: 1px solid #eee; padding-top: 10px; }</style></head><body><h1>${projectName}</h1><ul>${rootNodes.map(r => generateList(r.id)).join('')}</ul><div class="footer">Generated by Singularity ∞ MindMap</div></body></html>`;
    const blob = new Blob(['\ufeff', htmlContent], { type: 'application/msword' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `${projectName.replace(/\s+/g, '_')}.doc`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
};

export const printToPDF = (projectName: string) => {
    const originalTitle = document.title;
    document.title = projectName;
    if (!document.getElementById('print-style-override')) {
        const style = document.createElement('style');
        style.id = 'print-style-override';
        style.innerHTML = `@media print { body * { visibility: hidden; } #root, #root * { visibility: visible; } .no-print, button, .fixed, nav, .sidebar, .toolbar, .minimap, .creation-bar { display: none !important; } canvas { display: block !important; width: 100% !important; height: auto !important; } body { background: white !important; } }`;
        document.head.appendChild(style);
    }
    window.print();
    document.title = originalTitle;
};
